#!/bin/bash
clear
# set -x 옵션
#
#  종종 셸 스크립트에서 기초적인 문제 해결은 위에서 든 예처럼 쉽지 않다. 다른 모든 시도가 실패해서 벽에 머리를 찧고 있어도,
#  스크립트 실패 원인을 파악하지 못한다면 마지막 수단으로 대포를 꺼내자.
#  ksh이나 bash 같은 현대적인 셸은 set 명령어에 -x 스위치를 포함하고 있다. set -x 옵션을 사용하면,
#  평가된 모든 명령어가 확장되면서 표준 출력으로 나온다. 평가된 코드를 구분하기 위해 출력되는 모든 코드 행의 앞쪽에 PS4로 지정한 문자열을 표시한다.
#  상당히 많은 텍스트가 출력되므로 심호흡을 하고 천천히 살펴보자.
#  직전 예제에서 루프 횟수를 따지기 위해 주석과 함께 스크립트 첫 부분에 set -x 를 추가해 실행한다. Listing 12를 살펴보자.

#  Listing 12. set -x 예제

set -x

# 루프를 돌면서 몇 가지 테스트 구문을 출력한다.

_X=1

while [[ ${_X} -le 4 ]]
do
    [[ ${_X} -lt 2 ]] && echo "X is less than 2!"
    _Y=`expr ${_X} + 1`
    if [[ ${_Y} -eq 3 ]]
    then
        echo "Y is now equal to ${_Y}"
    fi
    _X=${_Y}
done

#  스크립트 수행에 앞서 PS4를 다른 출력 결과물과 구분이 가능한 문자열로 바꾼다.

export PS4="DEBUG => "

# 이제 Listing 13에서 보여주듯이 백사장에서 바늘 찾는 작업을 시작하자.


#  출력 결과를 보면 알겠지만 상당히 많은 정보가 화면에 표시된다. 모든 명령어를 평가해 수행한다.
#  셸 스크립트에서 주석 영역이 디버깅 정보에 출력되지 않음에 주목하자. 문자열이 주석이므로 평가 이후에 수행되지 못하기 때문이다.
#  다행스럽게 수정 이후에 이 스크립트에 잘못된 사항은 없어 보인다.
#
#  set -x 를 사용할 때 한 가지 주의해야 하는 사실이 있다. 평가하려는 스크립트가 내부 함수라면
#  set -x 를 코드 루트 본체에 둘 경우 자식 함수에 영향을 미친다는 사실이다. 하지만 set -x 를 내장 함수에 놓아두면,
#  단지 내부 함수 내부에서 호출되는 코드와 함수만 디버그 옵션을 따른다.
#  이럴 경우 셸 스크립트 루트 본체에서 디버그 옵션을 따르지 않는 이유는 이 루틴을 호출하는 자식 함수를 모르기 때문이다.