#!/bin/bash
# 예 7-2. [ ] 와 test 의 동일함

# [[ ]] 는 쉘 상에서 [ ]과 동일합니다. 이 명령어는 ksh88에서 따 온 확장 테스트 명령어입니다.
# 참고: [[ 과 ]] 사이에서는 파일명 확장이나 낱말 조각남이 일어나지 않지만 매개변수 확장이나 명령어 치환은 일어납니다.
# 작은 정보: [ ... ] 말고 [[ ... ]] 를 쓰면 많은 논리적 에러들을 막을 수 있습니다.
# 예를 들어 &&, ||, <, > 연산자들은 [ ] 에서 에러를 내지만 [[ ]] 에서는 잘 동작합니다.

echo

if test -z "$1"; then # test -z 는 문자열 길이가 0이면 true
  echo "명령어줄 인자가 없습니다."
else
  echo "첫번째 명령어줄 인자는 $1 입니다."
fi

if [ -z "$1" ]; then # 위의 코드 블럭과 기능적으로 동일합니다.
  #   if [ -z "$1"   라고 해도 동작하겠지만...
  #+  Bash 는 오른쪽 대괄호가 빠졌다고 에러 메세지를 냅니다.
  echo "명령어줄 인자가 없습니다."
else
  echo "첫번째 명령어줄 인자는 $1 입니다."
fi
echo

#1번과 2번의 결과는 다르다!
# 아무래도 논리적인 처리를 할때는 [[ ]] 를 사용하는 것이 좋겠다.
#1
if [ 1 -gt 2 ]; then
  echo "참"
else
  echo "거짓"
fi

#2
if [[ 1 > 2 ]]; then
  echo "참"
else
  echo "거짓"
fi



# 참고: if다음에 꼭 test나 테스트 대괄호( [ ]나 [[ ]] )가 나오지 않아도 됩니다.
dir="~/Documents/GitHub/"
if cd "$dir" 2>/dev/null; then   # "2>/dev/null" 는 에러 메세지를 숨겨줍니다.
  echo "현재 디렉토리는 $dir 입니다."
else
  echo "$dir 로 옮겨갈 수 없습니다."
fi




# 비슷하게, 테스트 대괄호가 리스트와 같이 쓰이면 if 없이 단독으로 쓰일 수도 있습니다.
# 연속으로 명렁어 실행시 차이점
# ; - 에러가 나도 그다음 명령이 실행      (ex) ls; pwd
# && - 에러가 나면 그다음 명령은 실행안됨. (ex) ls&& pwd
var1=20
var2=22
[ "$var1" -ne "$var2" ] && echo "$var1 는 $var2 와 같지 않습니다."

home=/home/bozo
[ -d "$home" ] || echo "$home 디렉토리는 존재하지 않는 디렉토리입니다."







exit 0
